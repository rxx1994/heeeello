对于字符串的首尾匹配
可以用
str.startswith()
str.endswith()
括号里面的部分可以是单个元素，也可以是多个元素构成的元组
！必须要用元组
执行操作后，会返回一个逻辑值
真/假

str.find('匹配条件')
是用来找到对应的目标的位置
会返回这个目标的索引


对于简单的匹配
可以用
fnmatch('需要匹配的字符串','匹配条件') #windows不区分大小写
fnmatchcase() #完全按照输入匹配

通配符
* 多位占位
？单个占位
[0-9] 数字占位
(.)匹配除了换行之外的任意字符，如果想要匹配换行符需要自己定义(?:.|\n)
!匹配的时候会自动返回最长的字符串
想要返回最短的：
在*后面加上？
*？同时出现作为占位符，则会返回匹配到的最短的字符串


复杂匹配：正则表达式
re.match()
re.match('匹配条件',str)
！仅检测字符串的开始部分

将某个匹配模式编译为对象，这样可以在接下来多次用到
re.compile(匹配条件)
如果想要精确匹配，需要用$作为匹配条件的结尾


正则表达式里面，匹配条件加了()
意味着给条件进行了分组
然后可以捕获这个分组
m.group
其中m可以是search()也可以是match()或者其他
总之就是一段要搜索的东西，包含了搜索（匹配）条件和搜索（匹配）对象
.group()==.group(0)
会输出整个匹配项
.group(1)对应的是第一项
.group(2)对应第二项
以此类推
m.groups() 返回所有括号匹配的字符，以tuple格式。m.groups() == (m.group(0), m.group(1), ...)
参考文献：https://www.cnblogs.com/3me-linux/p/6774674.html


pat.findall(text)
也可以返回匹配的文本
其中pat是已经编译好的匹配对象，也就是.compile()返回的值
findall返回的值是列表
！检查整改字符串

